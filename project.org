* simple-gl

** About
A high level library for using OpenGL.

** Overview

This is a minimalist, modern OpenGL library using GLFW.  It provides a framework for working
with shaders, buffers, textures, and user input.  The goal is to be a "playground" for OpenGL
development and make it easy to prototype OpenGL code.

*** Example REPL code
This is an example of how it's used from a REPL:

#+begin_src lisp
  (ql:quickload '(:spacenav :simple-gl :sgl-automata :sgl-blend2d-texture))
  (defparameter *viewer* (make-instance 'sgl:3d-viewer))
  (defparameter *cube* (make-instance 'sgl:opengl-object
                                      :buffers (list (make-instance 'sgl:stl-vertex-normal-buffer
                                                                    :filename "/home/jeremiah/data/3d-models/cube.stl")
                                                     (make-instance 'sgl:instance-buffer
                                                                    :attributes '(("in_color" . :vec4))
                                                                    :max-instances 100
                                                                    :initial-data (vec4 0.0 0.9 0.1 1.0))
                                                     (make-instance 'sgl:instance-buffer
                                                                    :attributes '(("obj_transform" . :mat4))
                                                                    :max-instances 100
                                                                    :initial-data (meye 4)))
                                      :styles (list `(:plastic-shader . ,(sgl:make-style-from-files
                                                                          "stl-plastic-vertex.glsl"
                                                                          "stl-plastic-fragment.glsl")))
                                      :current-style :plastic-shader
                                      :uniforms nil
                                      :textures nil))
    (sgl:add-object *viewer* :cube *cube*)
    (sgl:add-object *viewer* :textured-quad (sgl-blend2d-texture:blend2d-quad 2048))
    (sgl:display *viewer*)
#+end_src

#+RESULTS:
: #<SIMPLE-TASKS:CALL-TASK :FUNC #<FUNCTION (LAMBDA () :IN SIMPLE-GL:DISPLAY) {103BFF26AB}> :STATUS :SCHEDULED {103BFCB683}>

To create more complicated graphics, create a subclass of `opengl-object`, or `instanced-opengl-object` and overload the 'initialize-buffers' method.

#+begin_src lisp
  (defclass my-gl-object (sgl:opengl-object)
    ((sgl:primitive-type :initform :lines)))

  (defmethod sgl:initialize-uniforms ((object my-gl-object) &key)
    (call-next-method)
    ;; Initialize uniforms
    )
  (defmethod sgl:initialize-buffers ((object instanced-my-gl-object) &key)j
    (call-next-method)
    ;; Calls to (add-buffer ...)
    )
  (defmethod sgl:cleanup ((object my-gl-object))
    (call-next-method)
    ;; Cleanup any OpenGL resources
    )
#+end_src

** protocol-refactor Branch

*** Purpose

The purpose of this branch is to refactor the library so that it puts more
emphasis on OpenGL state management, and define exactly when methods like
"initialize-buffers" are called, and exactly what their responsibilities are.
Specifically I want to focus on updating state, because that's a pain point
right now, for things like buffers during animation.


The first step will be to refactor buffers to be congruent with shaders,
textures, and uniforms.  Standardize on thse methods:

*** These methods will run in a thread with a valid OpenGL context:

**** initialize
gl:gen-buffers - moved out of bind, gl:gen-textures, build-style (gl:create-program, gl:compile-shader, etc.)

**** bind
No longer initialize/gl:gen-buffers, only bind.  gl:bind-texture, gl:bind-buffer, etc.

**** fill
Transfer data to OpenGL.  gl:buffer-data, gl:buffer-sub-data, gl:tex-sub-image-*, possibly gl:program-uniform*

**** cleanup
Dispose of any OpenGL resources.

**** show-info
Print any relevant OpenGL information related to the object. Maybe just things that can't be seen in the inspector?

*** These methods can be called outside of an OpenGL context.
**** update
Change state.  Return a list of objects that need to be `fill`ed in the OpenGL context.  update runs in a threadpool
where multiple objects are updated at once.  The idea is to do the heavy lifting in update and make fill fast.
Right now update will wait for all objects to finish updating before calling fill, but this may be optimized so that
objects that aren't finished updating simply don't draw, or draw using their previous data.



`buffers` will subclass `attribute-buffer`, `instance-buffer`

An opengl-object will be a collection of named shaders, buffers, uniforms, and textures
that can be enabled or disabled.

I'd also like to refactor the (display viewer) method to be more explicit about
operations that need to run in the OpenGL thread.


** Future Ideas

*** Things to Borrow From Emacs

Some Emacs features that would be nice to have or interesting to try:

**** Modes
Instead of viewer subclasses, assign a major-mode to the viewer, such as
"automata-mode", "2d-complex-fractal-mode" or "3d-view-mode".  Input handling,
rendering, updating, etc. would be handled by the mode.

Are viewer subclasses and "major-modes" equivalent?  Would the architecture be
clearer by treating viewer subclasses more like modes?

What data should be associated with a mode?  What's the boundary between the
viewer and a major mode?  Should the list of objects in viewer belong in the
viewer or in the modes?

Minor modes would also be possible, but I'm not sure how useful they can be with
unrelated major-modes.  Maybe they are more dependant on major-modes than Emacs
minor-modes.

**** Keybindings
Instead of a handle-key method, use a map of (kbd "...") entries to handlers.
The viewer's key handler converts the current key stroke into a (kbd "...") and
calls the appropriate function.

One advantage is being able to print out the keyboard handlers.  Another is the
ability to change handlers at runtime.  Could have an "initialize-keyhandlers"
method?

Care should be taken to allow handling multiple keys with the same handler (such
as arrow keys, movement keys, etc.) which may need the key itself as a
parameter.  The handler should take parameters (viewer (kbd "...") window key
scancode action mod-keys) to allow that kind of re-use.  It's discouraged to
register the same handler for all keys.





* TODO Items
** TODO Better document API and library usage
** TODO Refactor glfw out of viewer base class and into glfw-viewer
** TODO offscreen-viewer classes
** TODO Make rebuilding styles safer.  Right now, rebuilding with a syntax error causes a crash.


** License
ISC

Copyright (c) 2023 Jeremiah LaRocco <jeremiah_larocco@fastmail.com>




